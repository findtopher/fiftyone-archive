import { promises as fs } from 'fs';
import path from 'path';

const OSS_IMPORT_LOOKUP_MAX_LINE_NUMBER_LIMIT = 20;
const OSS_ROOT_DIR = '../../.oss';

const DO_NOT_EDIT_COMMENT = `/**
 * 
 * THIS FILE WAS DYNAMICALLY GENERATED FROM ITS OSS COUNTERPART. DO NOT EDIT THIS FILE!
*/
`;

const mapImport = (line: string) => {
  /**
   * 1. change imports from src/oss/fixtures to src/teams/fixtures
   * 2. change other imports from src/... to .oss/...
   */
  if (line.startsWith('import') && line.includes('"src/oss/fixtures')) {
    return line.replace(/src\/oss\/fixtures/, 'src/teams/fixtures');
  }

  return line.replace(/"src\//, '".oss/');
};

const getFileContentWithModifiedImports = async (buffer: string) => {
  const lines = buffer.split('\n');
  const firstNLines = lines.slice(0, OSS_IMPORT_LOOKUP_MAX_LINE_NUMBER_LIMIT);

  const importMappedLines = firstNLines.map(mapImport);

  const newFileContent = [
    ...importMappedLines,
    ...lines.slice(OSS_IMPORT_LOOKUP_MAX_LINE_NUMBER_LIMIT)
  ].join('\n');
  return newFileContent;
};

const modifyFilesInDir = async (directory: string) => {
  const files = await fs.readdir(directory);

  for (const file of files) {
    const filePath = path.join(directory, file);
    const stats = await fs.stat(filePath);

    if (stats.isDirectory()) {
      await modifyFilesInDir(filePath);
    } else if (stats.isFile()) {
      const fileBuffer = await fs.readFile(filePath, 'utf-8');
      const newBuffer = await getFileContentWithModifiedImports(fileBuffer);
      const modifiedContent =
        DO_NOT_EDIT_COMMENT + '\n' + newBuffer + '\n' + DO_NOT_EDIT_COMMENT;
      await fs.writeFile(filePath, modifiedContent);
    }
  }
};

const setupOss = async () => {
  await modifyFilesInDir(path.resolve(__dirname, OSS_ROOT_DIR));
};

setupOss();
