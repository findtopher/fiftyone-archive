"""
Video frame views.

| Copyright 2017-2021, Voxel51, Inc.
| `voxel51.com <https://voxel51.com/>`_
|
"""
from copy import deepcopy

from bson import ObjectId

import eta.core.utils as etau

import fiftyone.core.sample as fos
import fiftyone.core.odm as foo
import fiftyone.core.view as fov


_DEFAULT_FIELDS = {
    "_id",
    "_rand",
    "_media_type",
    "filepath",
    "metadata",
    "tags",
    "frame_number",
    "frame_id",
}


class FrameView(fos.SampleView):
    """A frame in a :class:`FramesView`.

    :class:`FrameView` instances should not be created manually; they are
    generated by iterating over :class:`FramesView` instances.

    Args:
        doc: a :class:`fiftyone.core.odm.DatasetSampleDocument`
        view: the :class:`FramesView` that the frame belongs to
        selected_fields (None): a set of field names that this view is
            restricted to
        excluded_fields (None): a set of field names that are excluded from
            this view
        filtered_fields (None): a set of field names of list fields that are
            filtered in this view
    """

    @property
    def sample_id(self):
        """The ID of the sample to which this frame belongs."""
        return str(self._sample_id)

    def save(self):
        super().save()

        # Update source collection
        self._view._sync_source_sample(self)


class FramesView(fov.DatasetView):
    """A :class:`fiftyone.core.view.DatasetView` of frames from a video
    :class:`fiftyone.core.dataset.Dataset`.

    Frames views contain an ordered collection of frames, each of which
    corresponds to a single frame of a video from the source collection.

    Frames retrieved from frames views are returned as :class:`FrameView`
    objects.

    Args:
        source_collection: the
            :class:`fiftyone.core.collections.SampleCollection` from which this
            view was created
        frames_stage: the :class:`fiftyone.core.stages.ToFrames` stage that
            defines how the frames were created
        frames_dataset: the :class:`fiftyone.core.dataset.Dataset` that serves
            the frames in this view
    """

    _SAMPLE_CLS = FrameView

    def __init__(
        self, source_collection, frames_stage, frames_dataset, _stages=None
    ):
        if _stages is None:
            _stages = []

        self._source_collection = source_collection
        self._frames_stage = frames_stage
        self._frames_dataset = frames_dataset
        self.__stages = _stages

    def __copy__(self):
        return self.__class__(
            self._source_collection,
            deepcopy(self._frames_stage),
            self._frames_dataset,
            _stages=deepcopy(self.__stages),
        )

    @property
    def _dataset(self):
        return self._frames_dataset

    @property
    def _root_dataset(self):
        return self._source_collection._root_dataset

    @property
    def _stages(self):
        return self.__stages

    @property
    def _all_stages(self):
        return (
            self._source_collection.view()._all_stages
            + [self._frames_stage]
            + self.__stages
        )

    @property
    def name(self):
        return self.dataset_name + "-frames"

    def tag_labels(self, tags, label_fields=None):
        if etau.is_str(label_fields):
            label_fields = [label_fields]

        super().tag_labels(tags, label_fields=label_fields)

        # Update source collection

        if label_fields is None:
            fields = self._frames_dataset._get_label_fields()
        else:
            fields = label_fields

        def sync_fcn(view, field):
            view.tag_labels(tags, label_fields=[field])

        self._sync_source_fcn(sync_fcn, fields)

    def untag_labels(self, tags, label_fields=None):
        if etau.is_str(label_fields):
            label_fields = [label_fields]

        super().untag_labels(tags, label_fields=label_fields)

        # Update source collection

        if label_fields is None:
            fields = self._frames_dataset._get_label_fields()
        else:
            fields = label_fields

        def sync_fcn(view, field):
            view.untag_labels(tags, label_fields=[field])

        self._sync_source_fcn(sync_fcn, fields)

    def save(self, fields=None):
        if etau.is_str(fields):
            fields = [fields]

        super().save(fields=fields)

        # Update source collection

        self._sync_source_save(fields=fields)

    def reload(self):
        self._root_dataset.reload()

        #
        # Regenerate the frames dataset
        #
        # This assumes that calling `load_view()` when the current patches
        # dataset has been deleted will cause a new one to be generated
        #

        self._frames_dataset.delete()
        _view = self._frames_stage.load_view(self._source_collection)
        self._frames_dataset = _view._frames_dataset

    def _sync_source_sample(self, sample):
        self._sync_source_schema()

        updates = {
            k: v
            for k, v in sample.to_mongo_dict().items()
            if k not in _DEFAULT_FIELDS
        }

        self._source_collection._dataset._frame_collection.update_one(
            {"_id": ObjectId(sample.frame_id)}, {"$set": updates}
        )

    def _sync_source_fcn(self, sync_fcn, fields):
        for field in fields:
            frame_field = self._FRAMES_PREFIX + field
            _, id_path = self._get_label_field_path(field, "id")
            ids = self.values(id_path, unwind=True)
            source_view = self._source_collection.select_labels(
                ids=ids, fields=frame_field
            )
            sync_fcn(source_view, frame_field)

    def _sync_source_save(self, fields=None):
        self._sync_source_schema(fields=fields)

        pipeline = []

        if fields is None:
            default_fields = _DEFAULT_FIELDS.copy()
            default_fields.discard("frame_number")
            pipeline.append({"$unset": list(default_fields)})
        else:
            pipeline.append({"$project": {f: True for f in fields}})

        pipeline.append(
            {
                "$merge": {
                    "into": self._source_collection._dataset._frame_collection_name,
                    "on": ["_sample_id", "frame_number"],
                    "whenMatched": "merge",
                    "whenNotMatched": "discard",
                }
            }
        )

        self._aggregate(pipeline)

    def _sync_source_schema(self, fields=None):
        schema = self.get_field_schema()
        src_schema = self._source_collection.get_frame_field_schema()

        add_fields = []
        delete_fields = []

        if fields is not None:
            # We're syncing specific fields; if they are not present in source
            # collection, add them
            for field_name in fields:
                if field_name not in src_schema:
                    add_fields.append(field_name)
        else:
            # We're syncing all fields; add any missing fields to source
            # collection and delete any source fields that aren't in this view
            for field_name in schema.keys():
                if field_name not in src_schema:
                    add_fields.append(field_name)

            for field_name in src_schema.keys():
                if field_name not in schema:
                    delete_fields.append(field_name)

        for field_name in add_fields:
            field_kwargs = foo.get_field_kwargs(schema[field_name])
            self._source_collection._dataset.add_frame_field(
                field_name, **field_kwargs
            )

        for field_name in delete_fields:
            self._source_collection._dataset.delete_frame_field(field_name)
