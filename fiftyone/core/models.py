"""
FiftyOne models.

| Copyright 2017-2020, Voxel51, Inc.
| `voxel51.com <https://voxel51.com/>`_
|
"""
import warnings

import eta.core.image as etai
import eta.core.learning as etal
import eta.core.video as etav

import fiftyone.core.frame_utils as fofu
import fiftyone.core.labels as fol
import fiftyone.core.media as fom
import fiftyone.core.utils as fou


def apply_model(samples, model, label_field, confidence_thresh=None):
    """Applies the :class:`Model` to the samples in the collection.

    Args:
        samples: a :class:`fiftyone.core.collections.SampleCollection`
        model: a :class:`Model`
        label_field: the name (or prefix) of the field in which to store the
            model predictions
        confidence_thresh (None): an optional confidence threshold to apply to
            any classifications/objects generated by the model
    """
    if samples.media_type == fom.VIDEO:
        _apply_video_model(samples, model, label_field, confidence_thresh)
    else:
        _apply_image_model(samples, model, label_field, confidence_thresh)


class ModelConfig(etal.ModelConfig):
    """Base configuration class that encapsulates the name of a :class:`Model`
    and an instance of its associated Config class.

    Args:
        type: the fully-qualified class name of the :class:`Model` subclass
        config: an instance of the Config class associated with the model
    """

    pass


class Model(etal.Model):
    """Abstract base class for all models.

    This class declares the following conventions:

        (a) :meth:`Model.__init__` should take a single `config` argument that
            is an instance of `<ModelClass>Config`

        (b) Models implement the context manager interface. This means that
            models can optionally use context to perform any necessary setup
            and teardown, and so any code that builds a model should use the
            `with` syntax
    """

    def predict(self, arg):
        """Peforms prediction on the given data.

        Args:
            arg: the data

        Returns:
            a :class:`fiftyone.core.labels.Label` instance containing the
            predictions
        """
        raise NotImplementedError("subclasses must implement predict()")

    def predict_all(self, args):
        """Performs prediction on the given iterable of data.

        Subclasses can override this method to increase efficiency, but, by
        default, this method simply iterates over the data and applies
        :meth:`predict` to each.

        Args:
            args: an iterable of data

        Returns:
            a list of :class:`fiftyone.core.labels.Label` instances containing
            the predictions
        """
        return [self.predict(arg) for arg in args]


def _apply_image_model(samples, model, label_field, confidence_thresh):
    with model:
        with fou.ProgressBar() as pb:
            for sample in pb(samples):
                # Perform prediction
                img = etai.read(sample.filepath)
                label = model.predict(img)

                # Save labels
                _save_labels(sample, label, label_field, confidence_thresh)
                sample.save()


def _apply_video_model(samples, model, label_field, confidence_thresh):
    with model:
        with fou.ProgressBar() as pb:
            for sample in pb(samples):
                # Perform prediction
                with etav.FFmpegVideoReader(sample.filepath) as video_reader:
                    label = model.predict(video_reader)

                # Save labels
                _save_labels(sample, label, label_field, confidence_thresh)
                sample.save()


def _save_labels(sample, label, label_field, confidence_thresh):
    if label_field:
        label_key = lambda k: label_field + "_" + k
    else:
        label_key = lambda k: k

    if confidence_thresh:
        label = _apply_confidence_thresh(label, confidence_thresh)

    if _is_frames_dict(label):
        # Frame labels
        sample.frames.merge(
            {
                frame_number: {
                    label_key(fname): flabel
                    for fname, flabel in frame_dict.items()
                }
                for frame_number, frame_dict in label.items()
            }
        )
    elif isinstance(label, dict):
        # Multiple sample-level field
        sample.update_fields({label_key(k): v for k, v in label.items()})
    elif label is not None:
        # Single sample-level field
        sample[label_field] = label


def _apply_confidence_thresh(label, confidence_thresh):
    if _is_frames_dict(label):
        label = {
            frame_number: _apply_confidence_thresh(
                frame_dict, confidence_thresh
            )
            for frame_number, frame_dict in label.items()
        }
    elif isinstance(label, dict):
        label = {
            k: _apply_confidence_thresh(v, confidence_thresh)
            for k, v in label.items()
        }
    elif isinstance(label, (fol.Classification, fol.Detection)):
        if label.confidence is None or label.confidence < confidence_thresh:
            label = None
    elif isinstance(label, fol.Classifications):
        label.classifications = [
            c
            for c in label.classifications
            if c.confidence is not None and c.confidence >= confidence_thresh
        ]
    elif isinstance(label, fol.Detections):
        label.detections = [
            d
            for d in label.detections
            if d.confidence is not None and d.confidence >= confidence_thresh
        ]
    elif label is not None:
        msg = "Ignoring unsupported label type '%s'" % label.__class__
        warnings.warn(msg)

    return label


def _is_frames_dict(label):
    return (
        label
        and isinstance(label, dict)
        and fofu.is_frame_number(next(iter(label.keys())))
    )
