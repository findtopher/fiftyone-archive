"""
Patches views.

| Copyright 2017-2021, Voxel51, Inc.
| `voxel51.com <https://voxel51.com/>`_
|
"""
from copy import deepcopy
import itertools

import eta.core.utils as etau

import fiftyone.core.aggregations as foa
import fiftyone.core.labels as fol
import fiftyone.core.sample as fos
import fiftyone.core.view as fov


class PatchView(fos.SampleView):
    """A patch in a :class:`PatchesView`.

    :class:`PatchView` instances should not be created manually; they are
    generated by iterating over :class:`PatchesView` instances.

    Args:
        doc: a :class:`fiftyone.core.odm.DatasetSampleDocument`
        view: the :class:`PatchesView` that the patch belongs to
        selected_fields (None): a set of field names that this patch view is
            restricted to
        excluded_fields (None): a set of field names that are excluded from
            this patch view
        filtered_fields (None): a set of field names of list fields that are
            filtered in this patch view
    """

    def save(self, update_source=True):
        """Saves the patch to the database.

        Args:
            update_source (True): whether to push changes to the source dataset
        """
        super().save()

        if update_source:
            self._view._sync_source_sample(self)


class EvaluationPatchView(fos.SampleView):
    """A patch in an :class:`EvaluationPatchesView`.

    :class:`EvaluationPatchView` instances should not be created manually; they
    are generated by iterating over :class:`EvaluationPatchesView` instances.

    Args:
        doc: a :class:`fiftyone.core.odm.DatasetSampleDocument`
        view: the :class:`EvaluationPatchesView` that the patch belongs to
        selected_fields (None): a set of field names that this patch view is
            restricted to
        excluded_fields (None): a set of field names that are excluded from
            this patch view
        filtered_fields (None): a set of field names of list fields that are
            filtered in this patch view
    """

    def save(self, update_source=True):
        """Saves the patch to the database.

        Args:
            update_source (True): whether to push changes to the source dataset
        """
        super().save()

        if update_source:
            self._view._sync_source_sample(self)


class _PatchesView(fov.DatasetView):
    def __init__(
        self, source_collection, patches_stage, patches_dataset, _stages=None
    ):
        if _stages is None:
            _stages = []

        self._source_collection = source_collection
        self._patches_stage = patches_stage
        self._patches_dataset = patches_dataset
        self._stages = _stages

    def __copy__(self):
        return self.__class__(
            self._source_collection,
            deepcopy(self._patches_stage),
            self._patches_dataset,
            _stages=deepcopy(self._stages),
        )

    @property
    def _label_fields(self):
        raise NotImplementedError("subclass must implement _label_fields")

    @property
    def _dataset(self):
        return self._patches_dataset

    @property
    def _root_dataset(self):
        return self._source_collection._root_dataset

    @property
    def _element_str(self):
        return "patch"

    @property
    def _elements_str(self):
        return "patches"

    @property
    def _all_stages(self):
        return (
            self._source_collection.view()._all_stages
            + [self._patches_stage]
            + self._stages
        )

    @property
    def name(self):
        return self.dataset_name + "-patches"

    def tag_samples(self, tags, update_source=True):
        """Adds the tag(s) to all samples in this collection, if necessary.

        Args:
            tags: a tag or iterable of tags
            update_source (True): whether to add the tags to the labels in the
                source dataset
        """
        super().tag_samples(tags)

        if update_source:

            def sync_fcn(view, fields=None):
                view.tag_labels(tags, label_fields=fields)

            self._sync_source_fcn(sync_fcn, fields=self._label_fields)

    def untag_samples(self, tags, update_source=True):
        """Removes the tag(s) from all samples in this collection, if
        necessary.

        Args:
            tags: a tag or iterable of tags
            update_source (True): whether to push changes to the source dataset
        """
        super().untag_samples(tags)

        if update_source:

            def sync_fcn(view, fields=None):
                view.untag_labels(tags, label_fields=fields)

            self._sync_source_fcn(sync_fcn, fields=self._label_fields)

    def tag_labels(self, tags, label_fields=None, update_source=True):
        """Adds the tag(s) to all labels in the specified label field(s) of
        this collection, if necessary.

        Args:
            tags: a tag or iterable of tags
            label_fields (None): an optional name or iterable of names of
                :class:`fiftyone.core.labels.Label` fields. By default, all
                label fields are used
            update_source (True): whether to push changes to the source dataset
        """
        if etau.is_str(label_fields):
            label_fields = [label_fields]

        super().tag_labels(tags, label_fields=label_fields)

        if update_source:
            if label_fields is None:
                fields = self._label_fields
            else:
                fields = [l for l in label_fields if l in self._label_fields]

            def sync_fcn(view, fields=None):
                view.tag_labels(tags, label_fields=fields)

            self._sync_source_fcn(sync_fcn, fields=fields)

    def untag_labels(self, tags, label_fields=None, update_source=True):
        """Removes the tag from all labels in the specified label field(s) of
        this collection, if necessary.

        Args:
            tags: a tag or iterable of tags
            label_fields (None): an optional name or iterable of names of
                :class:`fiftyone.core.labels.Label` fields. By default, all
                label fields are used
            update_source (True): whether to push changes to the source dataset
        """
        if etau.is_str(label_fields):
            label_fields = [label_fields]

        super().untag_labels(tags, label_fields=label_fields)

        if update_source:
            if label_fields is None:
                fields = self._label_fields
            else:
                fields = [l for l in label_fields if l in self._label_fields]

            def sync_fcn(view, fields=None):
                view.untag_labels(tags, label_fields=fields)

            self._sync_source_fcn(sync_fcn, fields=fields)

    def save(self, fields=None, update_source=True):
        """Overwrites the underlying dataset with the contents of the view.

        .. warning::

            This will permanently delete any omitted, filtered, or otherwise
            modified contents of the dataset.

        Args:
            fields (None): an optional field or list of fields to save. If
                specified, only these fields are overwritten
            update_source (True): whether to push changes to the source dataset
        """
        if etau.is_str(fields):
            fields = [fields]

        super().save(fields=fields)

        if update_source:
            if fields is None:
                fields = self._label_fields
            else:
                fields = [l for l in fields if l in self._label_fields]

            self._sync_source_all(fields=fields)

    def _sync_source_sample(self, sample):
        for field in self._label_fields:
            self._sync_source_sample_field(sample, field)

    def _sync_source_sample_field(self, sample, field):
        # @todo precompute this for each field?
        label_type = self._patches_dataset._get_label_field_type(field)
        is_list_field = issubclass(label_type, fol._LABEL_LIST_FIELDS)

        doc = sample._doc.field_to_mongo(sample, field)

        # Merge sample-level tags into label tags
        if is_list_field:
            doc = doc.get(label_type._LABEL_LIST_FIELD, [])
            for _doc in doc:
                _doc["tags"].extend(sample.tags)
        else:
            doc["tags"].extend(sample.tags)

        self._source_collection._set_labels_by_id(
            field, [sample.sample_id], [doc]
        )

    def _sync_source_fcn(self, sync_fcn, fields):
        if etau.is_str(fields):
            fields = [fields]

        for field in fields:
            _, id_path = self._get_label_field_path(field, "id")
            ids = self.values(id_path, unwind=True)
            source_view = self._source_collection.select_labels(
                ids=ids, fields=field
            )
            sync_fcn(source_view, fields=field)

    def _sync_source_all(self, fields):
        if etau.is_str(fields):
            fields = [fields]

        for field in fields:
            self._sync_source_all_field(field)

    def _sync_source_all_field(self, field):
        # @todo precompute this for each field?
        label_type = self._patches_dataset._get_label_field_type(field)
        is_list_field = issubclass(label_type, fol._LABEL_LIST_FIELDS)

        _, id_path = self._get_label_field_path(field, "id")
        label_path = id_path.rsplit(".", 1)[0]

        #
        # Sync label updates
        #

        sample_ids, tags, docs = self.aggregate(
            [
                foa.Values("sample_id"),
                foa.Values("tags"),
                foa.Values(label_path),
            ]
        )

        # Merge sample-level tags into label tags
        if is_list_field:
            for _tags, _docs in zip(tags, docs):
                if not _tags:
                    continue

                for doc in _docs:
                    doc["tags"].extend(_tags)
        else:
            for _tags, doc in zip(tags, docs):
                if not _tags:
                    continue

                doc["tags"].extend(_tags)

        self._source_collection._set_labels_by_id(field, sample_ids, docs)

        #
        # Sync label deletions
        #

        if is_list_field:
            docs = list(
                itertools.chain.from_iterable(_docs for _docs in docs if _docs)
            )

        ids = [d["_id"]["$oid"] for d in docs]

        all_ids = self._patches_dataset.values(id_path, unwind=True)
        delete_ids = set(all_ids) - set(ids)

        if delete_ids:
            # @todo optimize by using `labels` syntax
            self._source_collection.delete_labels(ids=delete_ids, fields=field)


class PatchesView(_PatchesView):
    """A view of patches from a :class:`fiftyone.core.dataset.Dataset`.

    Patches views contain an ordered collection of patch samples, each of which
    contains a subset of a sample of the parent dataset corresponding to a
    single object or logical grouping of of objects.

    Patches views are :class:`fiftyone.core.view.DatasetView` instances, so
    they can be refined by adding :class:`fiftyone.core.stages.ViewStage`
    instances to them to create a chain of operations defining the patches
    of interest.

    Patches retrieved from patches views are returned as :class:`PatchView`
    objects.

    Args:
        source_collection: the
            :class:`fiftyone.core.collections.SampleCollection` from which this
            view was created
        patches_stage: the :class:`fiftyone.core.stages.ToPatches` stage that
            defines how the patches were extracted
        patches_dataset: the patches :class:`fiftyone.core.dataset.Dataset`
    """

    _SAMPLE_CLS = PatchView

    def __init__(
        self, source_collection, patches_stage, patches_dataset, _stages=None
    ):
        super().__init__(
            source_collection, patches_stage, patches_dataset, _stages=_stages
        )

        if _stages is None:
            _stages = []

        self._source_collection = source_collection
        self._patches_stage = patches_stage
        self._patches_dataset = patches_dataset
        self._stages = _stages

        self._patches_field = patches_stage.field

    @property
    def _label_fields(self):
        return [self._patches_field]

    @property
    def patches_field(self):
        """The field from which the patches in this view were extracted."""
        return self._patches_field


class EvaluationPatchesView(_PatchesView):
    """A view of evaluation patches from a
    :class:`fiftyone.core.dataset.Dataset`.

    Evalation patches views contain an ordered collection of evaluation
    examples, each of which contains the ground truth and/or predicted labels
    for a true positive, false positive, or false negative example from an
    evaluation run on the underlying dataset.

    Evalation patches views are :class:`fiftyone.core.view.DatasetView`
    instances, so they can be refined by adding
    :class:`fiftyone.core.stages.ViewStage` instances to them to create a chain
    of operations defining the patches of interest.

    Patches retrieved from patches views are returned as
    :class:`EvaluationPatchView` objects.

    Args:
        source_collection: the
            :class:`fiftyone.core.collections.SampleCollection` from which this
            view was created
        patches_stage: the :class:`fiftyone.core.stages.ToEvaluationPatches`
            stage that defines how the patches were extracted
        patches_dataset: the patches :class:`fiftyone.core.dataset.Dataset`
    """

    _SAMPLE_CLS = EvaluationPatchView

    def __init__(
        self, source_collection, patches_stage, patches_dataset, _stages=None
    ):
        super().__init__(
            source_collection, patches_stage, patches_dataset, _stages=_stages
        )

        eval_key = patches_stage.eval_key
        eval_info = source_collection.get_evaluation_info(eval_key)
        self._gt_field = eval_info.config.gt_field
        self._pred_field = eval_info.config.pred_field

    @property
    def _label_fields(self):
        return [self._gt_field, self._pred_field]

    @property
    def gt_field(self):
        """The ground truth field for the evaluation patches in this view."""
        return self._gt_field

    @property
    def pred_field(self):
        """The predictions field for the evaluation patches in this view."""
        return self._pred_field
