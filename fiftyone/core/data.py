"""
Core dataset definitions.

| Copyright 2017-2020, Voxel51, Inc.
| `voxel51.com <https://voxel51.com/>`_
|
"""
# pragma pylint: disable=redefined-builtin
# pragma pylint: disable=unused-wildcard-import
# pragma pylint: disable=wildcard-import
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals
from builtins import *

# pragma pylint: enable=redefined-builtin
# pragma pylint: enable=unused-wildcard-import
# pragma pylint: enable=wildcard-import

import datetime
import os

import eta.core.datasets as etads
import eta.core.image as etai
import eta.core.utils as etau

import fiftyone as fo
import fiftyone.constants as fc
import fiftyone.core.datautils as fodu
import fiftyone.core.utils as fou
import fiftyone.experimental.data as fed


def from_image_classification_samples(samples, labels_map=None, name=None):
    """Creates a :class:`fiftyone.experimental.data.Dataset` from the given
    image classification samples.

    The input ``samples`` can be any iterable that emits
    ``(image_path, target)`` tuples, where:

        - ``image_path`` is the path to the image on disk

        - ``target`` is either a label string, or, if a ``labels_map`` is
          provided, a class ID that can be mapped to a label string via
          ``labels_map[target]``

    For example, ``samples`` may be a ``torch.utils.data.Dataset`` or an
    iteratable generated by ``tf.data.Dataset.as_numpy_iterator()``.

    This operation will iterate over all provided samples, but the images will
    not be read.

    If your samples do not fit this schema, see
    :func:`from_labeled_image_samples` for details on how to provide your own
    :class:`fiftyone.core.datautils.LabeledImageSampleParser` that can parse
    your samples.

    Args:
        samples: an iterable of samples
        labels_map (None): an optional dict mapping class IDs to label strings.
            If provided, it is assumed that ``target`` is a class ID that
            should be mapped to a label string via ``labels_map[target]``
            :class:`fiftyone.core.datautils.ImageClassificationSampleParser` to
            use to parse the provided samples
        name (None): a name for the dataset. By default,
            :func:`get_default_dataset_name` is used

    Returns:
        a :class:`fiftyone.experimental.data.Dataset`
    """
    sample_parser = fodu.ImageClassificationSampleParser(labels_map=labels_map)
    return from_labeled_image_samples(
        samples, sample_parser=sample_parser, name=name,
    )


def from_image_detection_samples(samples, labels_map=None, name=None):
    """Creates a :class:`fiftyone.experimental.data.Dataset` from the given
    image detection samples.

    The input ``samples`` can be any iterable that emits
    ``(image_path, target)`` tuples, where:

        - ``image_path`` is the path to the image on disk

        - ``target`` is a list of detections in the following format::

            [
                {
                    "bbox": [top-left-x, top-left-y, width, height],
                    "label": label,
                    ...
                },
                ...
            ]

          where ``label`` is either a label string, or, if a ``labels_map`` is
          provided, a class ID that can be mapped to a bael string via
          ``labels_map[target]``, and the bounding box coordinates are relative
          values in ``[0, 1] x [0, 1]``

    For example, ``samples`` may be a ``torch.utils.data.Dataset`` or an
    iteratable generated by ``tf.data.Dataset.as_numpy_iterator()``.

    This operation will iterate over all provided samples, but the images will
    not be read.

    If your samples do not fit this schema, see
    :func:`from_labeled_image_samples` for details on how to provide your own
    :class:`fiftyone.core.datautils.LabeledImageSampleParser` that can parse
    your samples.

    Args:
        samples: an iterable of samples
        labels_map (None): an optional dict mapping class IDs to label strings.
            If provided, it is assumed that the ``label`` values in ``target``
            are class IDs that should be mapped to label strings via
            ``labels_map[target]``
        name (None): a name for the dataset. By default,
            :func:`get_default_dataset_name` is used

    Returns:
        a :class:`fiftyone.experimental.data.Dataset`
    """
    sample_parser = fodu.ImageDetectionSampleParser(labels_map=labels_map)
    return from_labeled_image_samples(
        samples, sample_parser=sample_parser, name=name,
    )


def from_labeled_image_samples(samples, sample_parser=None, name=None):
    """Creates a :class:`fiftyone.experimental.data.Dataset` from the given
    labeled image samples.

    The input ``samples`` can be any iterable that emits
    ``(image_path, image_labels)`` tuples, where:

        - ``image_path`` is the path to the image on disk

        - ``image_labels`` is an ``eta.core.image.ImageLabels`` instance, a
          serialized dict or string representation of one, or an arbitrary
          object that can be converted into this format by passing the sample
          to the :func:`fiftyone.core.datautils.LabeledImageSampleParser.parse_label`
          method of the provided ``sample_parser``

    For example, ``samples`` may be a ``torch.utils.data.Dataset`` or an
    iteratable generated by ``tf.data.Dataset.as_numpy_iterator()``.

    This operation will iterate over all provided samples, but the images will
    not be read.

    Args:
        samples: an iterable of samples
        sample_parser (None): an optional
            :class:`fiftyone.core.datautils.LabeledImageSampleParser` whose
            :func:`fiftyone.core.datautils.LabeledImageSampleParser.parse_label`
            method will be used to parse the ``image_labels`` in the provided
            samples
        name (None): a name for the dataset. By default,
            :func:`get_default_dataset_name` is used

    Returns:
        a :class:`fiftyone.experimental.data.Dataset`
    """
    if name is None:
        name = get_default_dataset_name()

    # Ingest labels
    image_paths = []
    labels = []
    for sample in samples:
        image_path, image_labels = sample

        # Ingest image path
        image_paths.append(os.path.abspath(image_path))

        # Ingest labels
        if sample_parser is not None:
            image_labels = sample_parser.parse_label(sample)

        image_labels = fou.parse_serializable(image_labels, etai.ImageLabels)
        labels.append(image_labels)

    return fed.Dataset.from_ground_truth_samples(name, image_paths, labels)


def from_labeled_image_dataset(dataset_dir, name=None):
    """Creates a :class:`fiftyone.experimental.data.Dataset` from the labeled
    image dataset in the given directory stored in
    ``eta.core.datasets.LabeledImageDataset`` format.

    See :func:`fiftyone.core.datautils.to_labeled_image_dataset` to convert
    your own samples into this format, if desired.

    Args:
        dataset_dir: a ``eta.core.datasets.LabeledImageDataset`` directory
        name (None): a name for the dataset. By default,
            :func:`get_default_dataset_name` is used

    Returns:
        a :class:`fiftyone.experimental.data.Dataset`
    """
    if name is None:
        name = get_default_dataset_name()

    labeled_dataset = etads.load_dataset(dataset_dir)
    return fed.Dataset.from_ground_truth_labeled_samples(name, labeled_dataset)


def from_images_from_dir(images_dir, recursive=False, name=None):
    """Creates a :class:`fiftyone.experimental.data.Dataset` from the given
    directory of images.

    This operation does not read the images.

    Args:
        images_dir: a directory of images
        recursive (False): whether to recursively traverse subdirectories
        name (None): a name for the dataset. By default,
            :func:`get_default_dataset_name` is used

    Returns:
        a :class:`fiftyone.experimental.data.Dataset`
    """
    image_paths = etau.list_files(
        images_dir, abs_paths=True, recursive=recursive
    )
    return from_images(image_paths, name=name)


def from_images_from_patt(image_patt, name=None):
    """Creates a :class:`fiftyone.experimental.data.Dataset` from the given
    glob pattern of images.

    This operation does not read the images.

    Args:
        image_patt: a glob pattern of images like ``/path/to/images/*.jpg``
        name (None): a name for the dataset. By default,
            :func:`get_default_dataset_name` is used

    Returns:
        a :class:`fiftyone.experimental.data.Dataset`
    """
    image_paths = etau.parse_glob_pattern(image_patt)
    return from_images(image_paths, name=name)


def from_images(image_paths, name=None):
    """Creates a :class:`fiftyone.experimental.data.Dataset` from the given
    list of images.

    This operation does not read the images.

    Args:
        image_paths: a list of image paths
        name (None): a name for the dataset. By default,
            :func:`get_default_dataset_name` is used

    Returns:
        a :class:`fiftyone.experimental.data.Dataset`
    """
    if name is None:
        name = get_default_dataset_name()

    image_paths = [os.path.abspath(p) for p in image_paths]

    return fed.Dataset.from_unlabeled_data(name, image_paths)


def get_default_dataset_name():
    """Returns a default dataset name based on the current time.

    Returns:
        a dataset name
    """
    return datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")


def get_default_dataset_dir(name, split=None):
    """Returns the default dataset directory for the dataset with the given
    name.

    Args:
        name: the dataset name
        split (None): an optional split

    Returns:
        the default dataset directory
    """
    dataset_dir = os.path.join(fo.config.default_dataset_dir, name)
    if split is not None:
        dataset_dir = os.path.join(dataset_dir, split)

    return dataset_dir
